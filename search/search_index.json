{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home Page","text":""},{"location":"#welcome-to-b-gyro","title":"Welcome to B-Gyro","text":"<p>\"Meet B-Gyro: our attempt at an operating system inspired by the gyroscope's stability... except ours wobbles more than it balances. Think of it as a gyroscope that moonlights as a boomerang\u2014it keeps coming back with more bugs to fix!\" -- by 0rayn and faithByte</p>"},{"location":"#features","title":"Features","text":"<ul> <li>32-bit operating system</li> <li>Developed by 0rayn and faithByte</li> <li>Debugging system using serial communication.</li> <li>partial-support for Ansi escape codes, for colored text.</li> <li>Minimalistic shell, with basic commands to interact with the system.</li> </ul>"},{"location":"#about-us","title":"About Us","text":"<p>We are a team of passionate developers working on creating a unique operating system. Our goal is to learn, innovate, and have fun along the way.</p>"},{"location":"#get-started","title":"Get Started","text":"<p>To get started with B-Gyro, check out our documentation.</p>"},{"location":"#contact","title":"Contact","text":"<p>For any inquiries or feedback, feel free to reach out to us at b.gyro.os@gmail.com</p>"},{"location":"gettingStarted/","title":"Welcome to B-Gyro","text":"<p>this document is a guide to help you get started with B-Gyro. If you have any questions or need help, feel free to reach out to us at b.gyro.os@gmail.com</p>"},{"location":"gettingStarted/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Prerequisites</li> <li>Play-Test</li> <li>kernel API</li> </ul>"},{"location":"gettingStarted/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, ensure you have met the following requirements: - docker and docker-compose installed on your machine. - qemu-system-x86_64 installed on your machine.</p>"},{"location":"gettingStarted/#play-test","title":"play-test:","text":"<p>To play-test B-Gyro, follow these steps:</p> <ol> <li>just clone the repository and run the following command: <pre><code>make\n</code></pre></li> <li>To run the operating system, run the following command: <pre><code>make run\n</code></pre></li> </ol>"},{"location":"gettingStarted/#kernel-api","title":"kernel API","text":"<ul> <li>Ports IO</li> <li>Serial Communication</li> <li>VGA Display</li> <li>Keyboard Input</li> <li>Memory Management</li> </ul>"},{"location":"kernel-API/_typedefs/","title":"Type Definitions","text":""},{"location":"kernel-API/_typedefs/#structs","title":"Structs","text":"<ul> <li>_vgaCell</li> <li>_node</li> <li>_list</li> <li>_tty</li> <li>_terminal</li> </ul>"},{"location":"kernel-API/_typedefs/#_vgacell","title":"_vgaCell","text":"<pre><code>typedef struct vgaCell\n{\n    char character;\n    char color;\n} _vgaCell;\n</code></pre> <p>&gt;&gt; Description:</p> <p>The _vgaCell is used to represent a character along with its associated color for rendering on the VGA screen. It stores the character and its color information, which can then be used to display the character with the correct color.</p> <p>&gt;&gt; Fields:</p> <ul> <li> <p>char <code>character</code>:     Where the actual character data is stored.</p> </li> <li> <p>uint8_t <code>color</code>:     The color associated with the character, represented as an integer. This integer is divided into two parts:  </p> <ul> <li>The first 4 bits (higher nibble) represent the background color.</li> <li>The second 4 bits (lower nibble) represent the foreground color (text).</li> </ul> </li> </ul>"},{"location":"kernel-API/_typedefs/#_node","title":"_node","text":"<pre><code>typedef struct node\n{\n    _vgaCell    *buffer;\n    struct node *previous;\n    struct node *next;\n} _node;\n</code></pre> <p>&gt;&gt; Description: The node struct represents a single element in a doubly linked list. Each node contains a buffer (_vgaCell*) that holds data, as well as pointers to the previous and next nodes in the list.</p> <p>&gt;&gt; Fields:</p> <ul> <li> <p>_vgaCell* buffer: A pointer to a _vgaCell array (buffer) that stores the data for this node.</p> </li> <li> <p>struct node* prev: A pointer to the previous node in the doubly linked list.</p> </li> <li> <p>struct node* next: A pointer to the next node in the doubly linked list.</p> </li> </ul>"},{"location":"kernel-API/_typedefs/#_list","title":"_list","text":"<pre><code>typedef struct list\n{\n    _node *first;\n    _node *last;\n    uint32_t size;\n} _list;\n</code></pre> <p>&gt;&gt; Description: The list struct represents a doubly linked list of node elements. This list stores multiple nodes, each containing a buffer (_vgaCell*).</p> <p>&gt;&gt; Fields: </p> <ul> <li> <p>_node* first: A pointer to the first node in the doubly linked list. This allows access to the start of the list.</p> </li> <li> <p>_node* last: A pointer to the last node in the doubly linked list. This allows access to the end of the list.</p> </li> <li> <p>uint8_t size: The size of the list. This value keeps track of how many nodes have been added to the list.</p> </li> </ul>"},{"location":"kernel-API/_typedefs/#_tty","title":"_tty","text":"<pre><code>typedef struct tty\n{\n    _list   *buffer;\n    _list   *history;\n\n    uint8_t index;\n\n    uint32_t posX;\n    uint32_t posY;\n\n    uint8_t textColor;\n    uint8_t backgroundColor;\n\n    _vgaCell status[MAX_COLUMNS];\n} _tty;\n</code></pre> <p>&gt;&gt; Description: The _tty stores the TTY's data;</p> <p>&gt;&gt; Fields:</p> <ul> <li> <p>_list *buffer: A pointer to a circular doubly linked list (_list) that stores the VGA data. This is where characters and their color information are saved before being rendered on the screen.</p> </li> <li> <p>_list2 *history: A pointer to a circular doubly linked list (_list) that stores the history of previous commands.</p> </li> <li> <p>uint8_t index: TTY index.</p> </li> <li> <p>uint8_t posX: The X-coordinate of the cursor position on the screen. This indicates the horizontal position where the next character will be printed.</p> </li> <li> <p>uint8_t posY: The Y-coordinate of the cursor position on the screen. This indicates the vertical position where the next character will be printed.</p> </li> <li> <p>uint8_t textColor: The current text color (foreground color) for characters that will be printed on the screen, specific to <code>tty[index]</code>.</p> </li> <li> <p>uint8_t backgroundColor: The current background color for characters that will be printed on the screen, specific to <code>tty[index]</code>.</p> <p>Note: We use global variables to store and get current colors; textColor and backgroundColor on this struct are only used when we need to switch TTYs.</p> </li> <li> <p>_vgaCell status[MAX_COLUMNS]: An array of _vgaCell (up to MAX_COLUMNS entries), each containing a character and its associated color. This array is used to store the current status of tty[index].</p> <p>_vgaCell status[MAX_COLUMNS] is always printed on the last row on the screen</p> </li> </ul>"},{"location":"kernel-API/_typedefs/#_terminal","title":"_terminal","text":"<pre><code>typedef struct terminal\n{\n    _tty ttys[MAX_TTYS];\n    _tty *currentTTY;\n} _terminal;\n</code></pre> <p>&gt;&gt; Description: The _terminal stores the terminal's data;</p> <p>&gt;&gt; Fields:</p> <ul> <li> <p>_tty ttys[MAX_TTYS]: An array of all available tty instances. MAX_TTYS represents the total number of terminals available.</p> </li> <li> <p>_tty *currentTTY: A pointer to the currently displayed tty.</p> </li> </ul>"},{"location":"kernel-API/keyboard-input/","title":"Keyboard Input","text":""},{"location":"kernel-API/keyboard-input/#functions","title":"Functions","text":""},{"location":"kernel-API/keyboard-input/#initialization-functions","title":"initialization functions","text":"<ul> <li>keyboardInit</li> <li>keyboardSetLayout</li> <li>keyboardSetBuffer</li> <li>keyboardClearBuffer</li> </ul>"},{"location":"kernel-API/keyboard-input/#promting","title":"promting","text":"<ul> <li>prompt</li> <li>interruptPrompting</li> </ul>"},{"location":"kernel-API/keyboard-input/#key-pressrelease-handlers","title":"key press/release handlers","text":"<ul> <li>keyboardSetKeyPressHandler</li> <li>keyboardSetKeyReleaseHandler</li> <li>keyboardResetKeyPressHandler</li> <li>keyboardResetKeyReleaseHandler</li> </ul>"},{"location":"kernel-API/keyboard-input/#convert-scancode-letter","title":"convert scancode &lt;=&gt; letter","text":"<ul> <li>keyboardGetScancode</li> <li>keyboardGetLetter</li> </ul>"},{"location":"kernel-API/keyboard-input/#shortcuts-handling-functions","title":"shortcuts handling functions","text":"<ul> <li>shortcutsReset</li> <li>setShortcut</li> </ul>"},{"location":"kernel-API/keyboard-input/#type-defs","title":"type defs","text":"<ul> <li>_kbdBuffer</li> <li>onKeyPressHanlder</li> <li>onKeyReleaseHanlder</li> <li>_shortcut</li> <li>onShortcutHandler</li> <li>_kbdLayout</li> </ul>"},{"location":"kernel-API/keyboard-input/#initialization-functions_1","title":"Initialization functions","text":""},{"location":"kernel-API/keyboard-input/#keyboardinit","title":"keyboardInit","text":"<p>&gt;&gt; Syntax: <pre><code>void    keyboardInit(void);\n</code></pre></p> <p>&gt;&gt; Description:</p> <p>initializes the keyboard driver by setting the keyboard buffer the current tty keyboard buffer, and default to the US keyboard layout.</p>"},{"location":"kernel-API/keyboard-input/#keyboardsetlayout","title":"keyboardSetLayout","text":"<p>&gt;&gt; Syntax: <pre><code>void keyboardSetLayout(_kbdLayout layout);\n</code></pre></p> <p>&gt;&gt; Description:</p> <p>Sets the keyboard layout to the provided layout (_kbdLayout).</p>"},{"location":"kernel-API/keyboard-input/#keyboardsetbuffer","title":"keyboardSetBuffer","text":"<p>&gt;&gt; Syntax: <pre><code>void keyboardSetBuffer(_kbdBuffer buffer);\n</code></pre></p> <p>&gt;&gt; Description:</p> <p>Sets the keyboard buffer to the provided buffer (_kbdBuffer).</p>"},{"location":"kernel-API/keyboard-input/#keyboardclearbuffer","title":"keyboardClearBuffer","text":"<p>&gt;&gt; Syntax: <pre><code>void keyboardClearBuffer(void);\n</code></pre></p> <p>&gt;&gt; Description:</p> <p>Clears the keyboard buffer.</p>"},{"location":"kernel-API/keyboard-input/#promting_1","title":"Promting","text":""},{"location":"kernel-API/keyboard-input/#prompt","title":"prompt","text":"<p>&gt;&gt; Syntax: <pre><code>char    *prompt(char *promtMessage, char *buffer);\n</code></pre></p> <p>&gt;&gt; Description:</p> <p>Prompts the user with the provided message and waits for the user to enter a string of characters, which will be stored in the provided buffer.</p> <p>&gt;&gt; Parameters:</p> <ul> <li>promtMessage: The message to be displayed to the user.</li> <li>buffer: The buffer to store the user input.</li> </ul> <p>&gt;&gt; Returns:</p> <p>The buffer containing the user input.</p> <p>&gt;&gt; Note:</p> <ul> <li>can be interrupted with (interruptPrompting).</li> <li>buffer overflow ?!</li> </ul>"},{"location":"kernel-API/keyboard-input/#interruptprompting","title":"interruptPrompting","text":"<p>&gt;&gt; Syntax: <pre><code>void interruptPrompting(void);\n</code></pre></p> <p>&gt;&gt; Description:</p> <p>Interrupts the current prompting operation.</p>"},{"location":"kernel-API/keyboard-input/#key-pressrelease-handlers_1","title":"Key press/release handlers","text":""},{"location":"kernel-API/keyboard-input/#keyboardsetkeypresshandler","title":"keyboardSetKeyPressHandler","text":"<p>&gt;&gt; Syntax: <pre><code>void keyboardSetKeyPressHandler(onKeyPressHanlder handler);\n</code></pre></p> <p>&gt;&gt; Description:</p> <p>Sets the key press handler to the provided handler (onKeyPressHanlder).</p>"},{"location":"kernel-API/keyboard-input/#keyboardsetkeyreleasehandler","title":"keyboardSetKeyReleaseHandler","text":"<p>&gt;&gt; Syntax: <pre><code>void keyboardSetKeyReleaseHandler(onKeyReleaseHanlder handler);\n</code></pre></p> <p>&gt;&gt; Description:</p> <p>Sets the key release handler to the provided handler (onKeyReleaseHanlder).</p>"},{"location":"kernel-API/keyboard-input/#keyboardresetkeypresshandler","title":"keyboardResetKeyPressHandler","text":"<p>&gt;&gt; Syntax: <pre><code>void keyboardResetKeyPressHandler(void);\n</code></pre></p> <p>&gt;&gt; Description:</p> <p>Resets the key press handler to the default handler (tty compatible).</p>"},{"location":"kernel-API/keyboard-input/#keyboardresetkeyreleasehandler","title":"keyboardResetKeyReleaseHandler","text":"<p>&gt;&gt; Syntax: <pre><code>void keyboardResetKeyReleaseHandler(void);\n</code></pre></p> <p>&gt;&gt; Description:</p> <p>Resets the key release handler to the default handler (tty compatible).</p>"},{"location":"kernel-API/keyboard-input/#convert-scancode-letter_1","title":"Convert scancode &lt;=&gt; letter","text":""},{"location":"kernel-API/keyboard-input/#keyboardgetscancode","title":"keyboardGetScancode","text":"<p>&gt;&gt; Syntax: <pre><code>uint8_t keyboardGetScancode(uint8_t letter);\n</code></pre></p> <p>&gt;&gt; Description:</p> <p>Returns the scancode of the provided letter.</p>"},{"location":"kernel-API/keyboard-input/#keyboardgetletter","title":"keyboardGetLetter","text":"<p>&gt;&gt; Syntax: <pre><code>uint8_t keyboardGetLetter(uint8_t scancode);\n</code></pre></p> <p>&gt;&gt; Description:</p> <p>Returns the letter of the provided scancode.</p>"},{"location":"kernel-API/keyboard-input/#shortcuts-handling-functions_1","title":"Shortcuts handling functions","text":""},{"location":"kernel-API/keyboard-input/#shortcutsreset","title":"shortcutsReset","text":"<p>&gt;&gt; Syntax: <pre><code>void shortcutsReset(void);\n</code></pre></p> <p>&gt;&gt; Description:</p> <p>Resets all the shortcuts.</p>"},{"location":"kernel-API/keyboard-input/#setshortcut","title":"setShortcut","text":"<p>&gt;&gt; Syntax: <pre><code>void setShortcut(_shortcut shortcut, onShortcutHandler handler);\n</code></pre></p> <p>&gt;&gt; Description:</p> <p>Sets the provided shortcut (_shortcut) to the provided handler (onShortcutHandler).</p>"},{"location":"kernel-API/keyboard-input/#type-defs_1","title":"type defs","text":""},{"location":"kernel-API/keyboard-input/#_kbdbuffer","title":"_kbdBuffer","text":"<pre><code>typedef struct kbdBuffer {\n    uint8_t     buffer[MAX_KEYBOARD_BUFFER];\n    uint32_t    index;\n    uint32_t    size;\n} _kbdBuffer;\n</code></pre> <p>&gt;&gt; Description:</p> <p>The _kbdBuffer struct represents a keyboard buffer.</p> <p>&gt;&gt; Fields:</p> <ul> <li>uint8_t buffer[MAX_KEYBOARD_BUFFER]: the buffer to store the keyboard input.</li> <li>uint32_t index: the current index in the buffer.</li> <li>uint32_t size: the size of the buffer.</li> </ul>"},{"location":"kernel-API/keyboard-input/#onkeypresshanlder","title":"onKeyPressHanlder","text":"<pre><code>typedef void (*onKeyPressHanlder)(uint8_t);\n</code></pre> <p>&gt;&gt; Description:</p> <p>The onKeyPressHanlder is a function pointer type that represents a key press handler.</p> <p>&gt;&gt; Parameters:</p> <ul> <li>uint8_t: pressed letter. (!= scancode)</li> </ul>"},{"location":"kernel-API/keyboard-input/#onkeyreleasehanlder","title":"onKeyReleaseHanlder","text":"<pre><code>typedef void (*onKeyReleaseHanlder)(uint8_t);\n</code></pre> <p>&gt;&gt; Description:</p> <p>The onKeyReleaseHanlder is a function pointer type that represents a key release handler.</p> <p>&gt;&gt; Parameters:</p> <ul> <li>uint8_t: the scancode of the released key.</li> </ul>"},{"location":"kernel-API/keyboard-input/#_shortcut","title":"_shortcut","text":"<pre><code>typedef struct shortcut {\n    char                key;\n    uint8_t             flagedModifiers;\n    onShortcutHandler   handler;\n} _shortcut;\n</code></pre> <p>&gt;&gt; Description:</p> <p>The _shortcut struct represents a keyboard shortcut.</p> <p>&gt;&gt; Fields:</p> <ul> <li>char key: the key of the shortcut.</li> <li>uint8_t flagedModifiers: the modifiers of the shortcut. (ctrl | alt | shift)</li> <li>onShortcutHandler handler: the handler of the shortcut.</li> </ul>"},{"location":"kernel-API/keyboard-input/#onshortcuthandler","title":"onShortcutHandler","text":"<pre><code>typedef void (*onShortcutHandler)(void);\n</code></pre> <p>&gt;&gt; Description:</p> <p>The onShortcutHandler is a function pointer type that represents a shortcut handler.</p>"},{"location":"kernel-API/keyboard-input/#_kbdlayout","title":"_kbdLayout","text":"<pre><code>typedef union kbdLayout {\n    struct keyboardViews kbdV;\n    uint8_t *views[2];\n} _kbdLayout;\n</code></pre> <p>&gt;&gt; Description:</p> <ul> <li>The _kbdLayout union represents a keyboard layout.</li> <li>the keyboard layout can be accessed as a struct (keyboardViews) or as an array of uint8_t pointers.</li> <li>keyboard layouts are declared in the keyboardDriver.c file.</li> </ul>"},{"location":"kernel-API/memory-management/","title":"Memory","text":""},{"location":"kernel-API/memory-management/#physical","title":"Physical","text":""},{"location":"kernel-API/memory-management/#framesbitmap","title":"framesBitmap","text":"<p>&gt;&gt; Syntax: <pre><code>uint8_t framesBitmap[THEORICAL_FRAMES_NUMBER / UINT8_SIZE]; \n</code></pre></p> <p>&gt;&gt; Description:</p> <p><code>framesBitmap</code> is an array of bits that tracks physical memory where:</p> <ul> <li>bit == 0 \u2192 frame is free</li> <li>bit == 1 \u2192 frame is allocated</li> </ul> <pre><code>                framesBitmap[0]                  framesBitmap[1] {8 bits == 8 frames}\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        +---+---+---+---+---+---+---+---++---+---+---+---+---+---+---+---+\n        | 1 | 0 | 0 | 1 | 1 | 0 | 0 | 1 || 1 | 0 | 0 | 1 | 1 | 0 | 0 | 1 |\n        +---+---+---+---+---+---+---+---++---+---+---+---+---+---+---+---+\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                8 physical frames\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        +------+------+------+------+------+------+------+------+\n        | PF 0 | PF 1 | PF 2 | PF 3 | PF 4 | PF 5 | PF 6 | PF 7 |\n        +------+------+------+------+------+------+------+------+\n                    PHYSICAL MEMORY (frames - 4kb per frame)\n</code></pre> <ul> <li>THEORICAL_FRAMES_NUMBER: total number of physical memory frames, assuming an entire 4 GB of physical memory is available for use.</li> </ul>"},{"location":"kernel-API/memory-management/#allocframe","title":"allocFrame","text":"<p>&gt;&gt; Syntax: <pre><code>uint32_t    allocFrame(uint32_t end);\n</code></pre></p> <p>&gt;&gt; Description:</p> <p>Searches the physical memory bitmap for a free frame, starting from the last search position to avoid rescanning from the beginning. If the end of the bitmap is reached, the search restarts from 0.  Once a free frame is found, its physical address is computed, the corresponding bitmap bit is set to 1 to mark it as allocated, and the address is returned.</p> <p>&gt;&gt; Parameters:</p> <ul> <li>end: always give it 0. #used to restart search from 0 in case the end of bitmap is reached </li> </ul>"},{"location":"kernel-API/memory-management/#freeframe","title":"freeFrame","text":"<p>&gt;&gt; Syntax: <pre><code>void    freeFrame(uint32_t ptr);\n</code></pre></p> <p>&gt;&gt; Description:</p> <p>Frees a previously allocated physical frame <code>ptr</code> by unsetting its corresponding bit in the physical memory bitmap, marking the frame as available again.</p>"},{"location":"kernel-API/memory-management/#getframeaddr","title":"getFrameAddr","text":"<p>&gt;&gt; Syntax: <pre><code>uint32_t    getFrameAddr(uint32_t vAddr);\n</code></pre></p> <p>&gt;&gt; Description:</p> <p>Translates a virtual address <code>vAddr</code> to its corresponding physical address using the page tables.</p>"},{"location":"kernel-API/memory-management/#virtual","title":"Virtual","text":""},{"location":"kernel-API/memory-management/#pagesbitmap","title":"pagesBitmap","text":"<p>&gt;&gt; Syntax: <pre><code>uint32_t    pagesBitmap[PAGES_BITMAP_SIZE]; \n</code></pre></p> <p>&gt;&gt; Description:</p> <p>Each 2 bits in the array <code>pagesBitmap</code> corresponds to a virtual page, and its value describes how that virtual address range is allocated:</p> <ul> <li>bits == 00 \u2192 page is free (== 4 kb address range unused)</li> <li>bits == 01 \u2192 first page of an allocated block</li> <li>bits == 10 \u2192 allocated page followed by another allocated page</li> <li>bits == 11 \u2192 last page of an allocated block</li> </ul> <pre><code>                                   pagesBitmap[0] {32 bits == 16 page}                                    \n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+\n|   00   |   00   |   00   |   00   |   01   |   10   |   10   |   10   |   10   |   11   |   00   |   00   |   00   |   11   |   00   |   00   |\n+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+--------+\n|        |                          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                          \u2514\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2518\n|        |                                            allocated block                                                allocated\n|        |                                          used address range                                      used address range [4kb]\n|        |                         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                           \u250c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2510\n0x1000   0x2000   0x3000   0x4000  [0x5000   0x6000   0x7000   0x8000   0x9000   0xA000  [0xB000   0xC000   0xD000  [0xE000  [0xF000   0x10000  0x11000\n</code></pre>"},{"location":"kernel-API/memory-management/#allocpages","title":"allocPages","text":"<p>&gt;&gt; Syntax: <pre><code>uint32_t    allocPages(uint32_t numberOfPages, uint32_t heapStart, uint32_t end);\n</code></pre></p> <p>&gt;&gt; Description:</p> <p>Allocates numberOfPages contiguous virtual memory pages.</p> <p>It finds numberOfPages consecutive free pages, sets the corresponding bits to allocated in the <code>pagesBitmap</code>, and returns the virtual address of the first page.</p> <p>The total allocated virtual address range is: <code>numberOfPages \u00d7 PAGE_SIZE bytes</code></p> <p>&gt;&gt; Parameters:</p> <ul> <li>numberOfPages: number of pages to allocate</li> <li>heapStart: the first address of the heap<ul> <li>KERNEL_HEAP_START: 0xC1000000</li> <li>USER_HEAP_START: 0x00001000</li> </ul> </li> </ul> <p><pre><code>                    Virtual Address Space (32-bit, 3 G / 1 G split)\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502 USER SPACE  (per-process)                                     \u2502\n        \u2502                                                               \u2502\n        \u2502 0x00000000 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        \u2502 |  NULL                                                       \u2502\n        \u2502                                                               \u2502\n        \u2502 0x00001000 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        \u2502 |  User code / data / heap / stack / mmap / libraries         \u2502\n        \u2502 |  (managed by each process\u2019s page directory)                 \u2502\n        \u2502 |  Typically up to 3 GB total                                 \u2502\n        \u2502                                                               \u2502\n        \u2502 0xBFFFFFFF \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        \u2502 Transition to kernel-only virtual addresses                   \u2502\n        \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        \u2502 KERNEL SPACE  (global, same in all processes)                 \u2502\n        \u2502                                                               \u2502\n        \u2502 0xC0000000 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        \u2502 |  Direct-mapped physical memory (\u201clowmem\u201d)                   \u2502\n        \u2502 |  Virtual = physical + 0xC0000000                            \u2502\n        \u2502 |  Contains:                                                  \u2502\n        \u2502 |   \u2022 kernel text/data/BSS                                    \u2502\n        \u2502 |   \u2022 page tables                                             \u2502\n        \u2502 |   \u2022 per-task kernel stacks (each 4\u20138 KB)                    \u2502\n        \u2502 |   \u2022 slab caches, low-mem pages                              \u2502\n        \u2502 |  [This region extends for size of physical lowmem]          \u2502\n        \u2502                                                               \u2502\n        \u2502                                                               \u2502\n        \u2502 0xC1000000 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        \u2502 |  Gap / alignment buffer (\u224816 MB by convention)              \u2502\n        \u2502 |  Prevents accidental overlap                                \u2502\n        \u2502                                                               \u2502\n        \u2502 0xC1000000 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        \u2502 |  Kernel \u201cheap\u201d / vmalloc area                               \u2502\n        \u2502 |  Used by:                                                   \u2502\n        \u2502 |   \u2022 vmalloc(), vmap()                                       \u2502\n        \u2502 |   \u2022 ioremap() mappings below Fixmap                         \u2502\n        \u2502 |  Virtually contiguous, physically discontiguous pages       \u2502\n        \u2502 |  (\u22480xC0800000\u20130xF7FFFFFF)                                   \u2502\n        \u2502                                                               \u2502\n        \u2502 0xF8000000 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        \u2502 |  High-mem temporary mappings (kmap, pkmap)                  \u2502\n        \u2502 |  IO-remap region                                            \u2502\n        \u2502 |  Architecture-specific mappings                             \u2502\n        \u2502                                                               \u2502\n        \u2502 0xFFF00000 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n        \u2502 |  Fixmap region                                              \u2502\n        \u2502 |   \u2022 APIC, BIOS, CPU local data                              \u2502\n        \u2502 |   \u2022 Kernel vsyscall page                                    \u2502\n        \u2502 |  Computed downward from 0xFFFFF000                          \u2502\n        \u2502                                                               \u2502\n        \u2502 0xFFFFFFFF \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> - end: always give it 0. #used to restart search from 0 in case the end of numberOfPages is reached</p>"},{"location":"kernel-API/memory-management/#freepages","title":"freePages","text":"<p>&gt;&gt; Syntax: <pre><code>size_t  freePages(uint32_t ptr, uint32_t heapStart);\n</code></pre></p> <p>&gt;&gt; Description:</p> <p>Frees a previously allocated contiguous virtual memory region.</p> <p>Using the ptr, it locates the allocation, frees all associated virtual pages by clearing the corresponding bits in the pagesBitmap, and returns the number of pages that were freed.</p> <p>&gt;&gt; Parameters:</p> <ul> <li>ptr: address to free</li> <li>heapStart: the first address of the heap<ul> <li>KERNEL_HEAP_START: 0xC1000000</li> <li>USER_HEAP_START: 0x00001000</li> </ul> </li> </ul> <p>&gt;&gt; Return:</p> <p>The number of pages that were freed.</p>"},{"location":"kernel-API/memory-management/#memory-mapping","title":"Memory mapping","text":""},{"location":"kernel-API/memory-management/#kmmap","title":"kmmap","text":"<p>&gt;&gt; Syntax:</p> <pre><code>void    *kmmap(size_t size);\n</code></pre> <p>&gt;&gt; Description:</p> <p>Maps a memory region of the given size in bytes.</p> <p>It calculates the required number of pages, allocates that many contiguous virtual pages, then allocates the same number of physical frames (which may be contiguous or non-contiguous, depending on availability). Then call mapPage.</p> <p>&gt;&gt; Return:</p> <p>The virtual address of the first page.</p>"},{"location":"kernel-API/memory-management/#mappage","title":"mapPage","text":"<p>&gt;&gt; Syntax: <pre><code>void    mapPage(uint32_t virtAddr, uint32_t physAddr, uint32_t flags);\n</code></pre></p> <p>&gt;&gt; Description:</p> <p>Maps a virtual page to a frame in the page directory </p>"},{"location":"kernel-API/memory-management/#kunmap","title":"kunmap","text":"<p>&gt;&gt; Syntax:</p> <pre><code>void    kunmap(uint32_t vaddr);\n</code></pre> <p>&gt;&gt; Description:</p> <p>Unmaps a previously mapped virtual memory region.</p> <p>Starting from vaddr, it frees the virtual pages and its corresponding physical frames. Than calls unmapPage</p>"},{"location":"kernel-API/memory-management/#unmappage","title":"unmapPage","text":"<p>&gt;&gt; Syntax: <pre><code>void    unmapPage(uint32_t virtAddr);\n</code></pre></p> <p>&gt;&gt; Description:</p> <p>Removes the corresponding entry of virtAddr from the page table (page directory)</p>"},{"location":"kernel-API/ports-io/","title":"Ports IO","text":""},{"location":"kernel-API/ports-io/#functions","title":"Functions:","text":"<ul> <li>portByteIn</li> <li>portByteOut</li> <li>portWordIn</li> <li>portWordOut</li> <li>ioWait</li> </ul>"},{"location":"kernel-API/ports-io/#portbytein","title":"portByteIn","text":"<p>&gt; Syntax: <pre><code>uint8_t portByteIn(uint16_t port);\n</code></pre></p> <p>&gt; Description: Reads a byte from the specified port.</p>"},{"location":"kernel-API/ports-io/#portbyteout","title":"portByteOut","text":"<p>&gt; Syntax: <pre><code>void portByteOut(uint16_t port, uint8_t data);\n</code></pre></p> <p>&gt; Description: Writes a byte to the specified port.</p>"},{"location":"kernel-API/ports-io/#portwordin","title":"portWordIn","text":"<p>&gt; Syntax: <pre><code>uint16_t portWordIn(uint16_t port);\n</code></pre></p> <p>&gt; Description: Reads a word (16 bit) from the specified port.</p>"},{"location":"kernel-API/ports-io/#portwordout","title":"portWordOut","text":"<p>&gt; Syntax: <pre><code>void portWordOut(uint16_t port, uint16_t data);\n</code></pre> &gt; Description: Writes a word (16 bit) to the specified port.</p>"},{"location":"kernel-API/ports-io/#iowait","title":"ioWait","text":"<p>&gt; Syntax: <pre><code>void ioWait(void);\n</code></pre></p> <p>&gt; Description: Wait a very small amount of time (1 to 4 microseconds, generally). Useful for implementing a small delay for PIC remapping on old hardware.</p>"},{"location":"kernel-API/serial-communication/","title":"Serial Communication","text":""},{"location":"kernel-API/serial-communication/#functions","title":"Functions","text":"<ul> <li>initSerial</li> <li>isTransmitEmpty</li> <li>serialPutChar</li> </ul>"},{"location":"kernel-API/serial-communication/#initserial","title":"initSerial","text":"<p>&gt; Syntax: <pre><code>int initSerial(void);\n</code></pre></p> <p>&gt; Description:</p> <p>Initializes the serial communication using the UART protocol.</p> <p>This function configures the COM1 port with the following settings: - Baud rate: 9600 - Data bits: 8 - Stop bits: 1 - Parity: None - Flow control: None (relies on THR status)</p> <p>Returns <code>0</code> on success, <code>1</code> if the serial chip is faulty.  </p>"},{"location":"kernel-API/serial-communication/#istransmitempty","title":"isTransmitEmpty","text":"<p>&gt; Syntax: <pre><code>int isTransmitEmpty(void);\n</code></pre></p> <p>&gt; Description:</p> <p>Checks if the transmit buffer is empty.</p> <p>This function returns <code>1</code> if the transmit buffer is empty, otherwise it returns <code>0</code>.</p>"},{"location":"kernel-API/serial-communication/#serialputchar","title":"serialPutChar","text":"<p>&gt; Syntax: <pre><code>uint8_t serialPutChar(char c);\n</code></pre></p> <p>&gt; Description:</p> <p>Sends a character over the serial port.</p> <p>This function places the character <code>c</code> into the transmit buffer and returns <code>1</code>. If the buffer is full, it waits until the buffer is empty and then places the character in the buffer.</p>"},{"location":"kernel-API/serial-communication/#note","title":"Note","text":"<p>All these functions use the COM1 port for serial communication.</p>"},{"location":"kernel-API/tty/","title":"TTY","text":""},{"location":"kernel-API/tty/#functions","title":"Functions","text":"<ul> <li>putChar</li> </ul>"},{"location":"kernel-API/tty/#putchar","title":"putChar","text":"<p>&gt;&gt; Syntax: <pre><code>uint8_t putChar(char c);\n</code></pre></p> <p>&gt;&gt; Description:</p> <p>Displays the character <code>c</code> on the VGA screen at the current cursor position and adds it to the tty buffer.</p> <p>&gt;&gt;&gt; Functionality:</p> <ul> <li>Displays the character <code>c</code> on the VGA screen at the current cursor position.   </li> <li>Adds the character and its associated color to the tty buffer.  </li> <li>Updates cursor position (X, Y) after printing the character.  </li> <li>Scrolls the screen when the cursor reaches (MAX_COLUMNS, MAX_ROWS).  </li> <li>Handles special characters:</li> </ul> character Represenation Terminal action \\n newline Moves the printing position to the beginning of the next line. \\r carriage return Moves the cursor to the beginning of the current line. \\t tab Advances the cursor by a tab space. \\b backspace Moves the printing position to the previous character position, unless the current position is the start of a line. \\033xx;..;xxm colors Applies text color and formatting, using ansi sequences. <p>&gt;&gt; Return Value:</p> <ul> <li>Returns 1 if the character was successfully printed.  </li> <li>Returns 0 if the character couldn't be printed.</li> </ul>"},{"location":"kernel-API/vga-display/","title":"vga display","text":""},{"location":"kernel-API/vga-display/#functions","title":"Functions","text":"<ul> <li>putCellOnVga</li> <li>setVgaColor</li> </ul>"},{"location":"kernel-API/vga-display/#putcellonvga","title":"putCellOnVga","text":"<p>&gt;&gt; Syntax: <pre><code>void putCellOnVga(_vgaCell cell, uint8_t x, uint8_t y);\n</code></pre></p> <p>&gt;&gt; Description:</p> <p>Takes a _vgaCell, which contains a character and its associated color, and prints it at the specified position (x, y) on the VGA screen. Uses the color information stored in the data struct to display the character with the correct color.</p> <p>&gt;&gt; Parameters:</p> <ul> <li>cell: A _vgaCell to be displayed.</li> <li>x: The X-coordinate on the VGA screen where the cell will be displayed.</li> <li>y: The Y-coordinate on the VGA screen where the cell will be displayed.</li> </ul>"},{"location":"kernel-API/vga-display/#setvgacolor","title":"setVgaColor","text":"<p>&gt;&gt; Syntax: <pre><code>void setVgaColor(uint8_t ansiNbr);\n</code></pre></p> <p>&gt;&gt; Description:</p> <p>Sets the current text or background color based on the provided <code>ansiNbr</code>.  It converts the ANSI color code into a corresponding VGA color and stores it as the current color for subsequent text or background rendering.</p> <p>&gt;&gt; Supported Color Codes:</p> Color Name VGA Text Color Background Color VGA Bright Text Color Bright Background Color Black 0 30 40 8 90 100 Blue 1 34 44 9 94 104 Green 2 32 42 10 92 102 Cyan 3 36 46 11 96 106 Red 4 31 41 12 91 101 Magenta 5 35 45 13 95 105 Yellow 6 33 43 14 93 103 White 7 37 47 15 97 107 Default - 39 49 - - - Reset - 0 0 - - -"}]}