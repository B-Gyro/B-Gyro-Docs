{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home Page","text":""},{"location":"#welcome-to-b-gyro","title":"Welcome to B-Gyro","text":"<p>\"Meet B-Gyro: our attempt at an operating system inspired by the gyroscope's stability... except ours wobbles more than it balances. Think of it as a gyroscope that moonlights as a boomerang\u2014it keeps coming back with more bugs to fix!\" -- by 0rayn and faithByte</p>"},{"location":"#features","title":"Features","text":"<ul> <li>32-bit operating system</li> <li>Developed by 0rayn and faithByte</li> <li>Debugging system using serial communication.</li> <li>partial-support for Ansi escape codes, for colored text.</li> <li>Minimalistic shell, with basic commands to interact with the system.</li> </ul>"},{"location":"#about-us","title":"About Us","text":"<p>We are a team of passionate developers working on creating a unique operating system. Our goal is to learn, innovate, and have fun along the way.</p>"},{"location":"#get-started","title":"Get Started","text":"<p>To get started with B-Gyro, check out our documentation.</p>"},{"location":"#contact","title":"Contact","text":"<p>For any inquiries or feedback, feel free to reach out to us at b.gyro.os@gmail.com</p>"},{"location":"gettingStarted/","title":"Welcome to B-Gyro","text":"<p>this document is a guide to help you get started with B-Gyro. If you have any questions or need help, feel free to reach out to us at b.gyro.os@gmail.com</p>"},{"location":"gettingStarted/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Prerequisites</li> <li>Play-Test</li> <li>kernel API</li> </ul>"},{"location":"gettingStarted/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, ensure you have met the following requirements: - docker and docker-compose installed on your machine. - qemu-system-x86_64 installed on your machine.</p>"},{"location":"gettingStarted/#play-test","title":"play-test:","text":"<p>To play-test B-Gyro, follow these steps:</p> <ol> <li>just clone the repository and run the following command: <pre><code>make\n</code></pre></li> <li>To run the operating system, run the following command: <pre><code>make run\n</code></pre></li> </ol>"},{"location":"gettingStarted/#kernel-api","title":"kernel API","text":"<ul> <li>Ports IO</li> <li>Serial Communication</li> <li>VGA Display</li> <li>Keyboard Input</li> <li>Memory Management</li> </ul>"},{"location":"kernel-API/_typedefs/","title":"Type Definitions","text":""},{"location":"kernel-API/_typedefs/#structs","title":"Structs","text":"<ul> <li>_vgaCell</li> <li>_node</li> <li>_list</li> <li>_tty</li> <li>_terminal</li> </ul>"},{"location":"kernel-API/_typedefs/#_vgacell","title":"_vgaCell","text":"<pre><code>typedef struct vgaCell\n{\n    char character;\n    char color;\n} _vgaCell;\n</code></pre> <p>&gt;&gt; Description:</p> <p>The _vgaCell is used to represent a character along with its associated color for rendering on the VGA screen. It stores the character and its color information, which can then be used to display the character with the correct color.</p> <p>&gt;&gt; Fields:</p> <ul> <li> <p>char <code>character</code>:     Where the actual character data is stored.</p> </li> <li> <p>uint8_t <code>color</code>:     The color associated with the character, represented as an integer. This integer is divided into two parts:  </p> <ul> <li>The first 4 bits (higher nibble) represent the background color.</li> <li>The second 4 bits (lower nibble) represent the foreground color (text).</li> </ul> </li> </ul>"},{"location":"kernel-API/_typedefs/#_node","title":"_node","text":"<pre><code>typedef struct node\n{\n    _vgaCell    *buffer;\n    struct node *previous;\n    struct node *next;\n} _node;\n</code></pre> <p>&gt;&gt; Description: The node struct represents a single element in a doubly linked list. Each node contains a buffer (_vgaCell*) that holds data, as well as pointers to the previous and next nodes in the list.</p> <p>&gt;&gt; Fields:</p> <ul> <li> <p>_vgaCell* buffer: A pointer to a _vgaCell array (buffer) that stores the data for this node.</p> </li> <li> <p>struct node* prev: A pointer to the previous node in the doubly linked list.</p> </li> <li> <p>struct node* next: A pointer to the next node in the doubly linked list.</p> </li> </ul>"},{"location":"kernel-API/_typedefs/#_list","title":"_list","text":"<pre><code>typedef struct list\n{\n    _node *first;\n    _node *last;\n    uint32_t size;\n} _list;\n</code></pre> <p>&gt;&gt; Description: The list struct represents a doubly linked list of node elements. This list stores multiple nodes, each containing a buffer (_vgaCell*).</p> <p>&gt;&gt; Fields: </p> <ul> <li> <p>_node* first: A pointer to the first node in the doubly linked list. This allows access to the start of the list.</p> </li> <li> <p>_node* last: A pointer to the last node in the doubly linked list. This allows access to the end of the list.</p> </li> <li> <p>uint8_t size: The size of the list. This value keeps track of how many nodes have been added to the list.</p> </li> </ul>"},{"location":"kernel-API/_typedefs/#_tty","title":"_tty","text":"<pre><code>typedef struct tty\n{\n    _list   *buffer;\n    _list   *history;\n\n    uint8_t index;\n\n    uint32_t posX;\n    uint32_t posY;\n\n    uint8_t textColor;\n    uint8_t backgroundColor;\n\n    _vgaCell status[MAX_COLUMNS];\n} _tty;\n</code></pre> <p>&gt;&gt; Description: The _tty stores the TTY's data;</p> <p>&gt;&gt; Fields:</p> <ul> <li> <p>_list *buffer: A pointer to a circular doubly linked list (_list) that stores the VGA data. This is where characters and their color information are saved before being rendered on the screen.</p> </li> <li> <p>_list2 *history: A pointer to a circular doubly linked list (_list) that stores the history of previous commands.</p> </li> <li> <p>uint8_t index: TTY index.</p> </li> <li> <p>uint8_t posX: The X-coordinate of the cursor position on the screen. This indicates the horizontal position where the next character will be printed.</p> </li> <li> <p>uint8_t posY: The Y-coordinate of the cursor position on the screen. This indicates the vertical position where the next character will be printed.</p> </li> <li> <p>uint8_t textColor: The current text color (foreground color) for characters that will be printed on the screen, specific to <code>tty[index]</code>.</p> </li> <li> <p>uint8_t backgroundColor: The current background color for characters that will be printed on the screen, specific to <code>tty[index]</code>.</p> <p>Note: We use global variables to store and get current colors; textColor and backgroundColor on this struct are only used when we need to switch TTYs.</p> </li> <li> <p>_vgaCell status[MAX_COLUMNS]: An array of _vgaCell (up to MAX_COLUMNS entries), each containing a character and its associated color. This array is used to store the current status of tty[index].</p> <p>_vgaCell status[MAX_COLUMNS] is always printed on the last row on the screen</p> </li> </ul>"},{"location":"kernel-API/_typedefs/#_terminal","title":"_terminal","text":"<pre><code>typedef struct terminal\n{\n    _tty ttys[MAX_TTYS];\n    _tty *currentTTY;\n} _terminal;\n</code></pre> <p>&gt;&gt; Description: The _terminal stores the terminal's data;</p> <p>&gt;&gt; Fields:</p> <ul> <li> <p>_tty ttys[MAX_TTYS]: An array of all available tty instances. MAX_TTYS represents the total number of terminals available.</p> </li> <li> <p>_tty *currentTTY: A pointer to the currently displayed tty.</p> </li> </ul>"},{"location":"kernel-API/keyboard-input/","title":"Keyboard Input","text":""},{"location":"kernel-API/keyboard-input/#functions","title":"Functions","text":""},{"location":"kernel-API/keyboard-input/#initialization-functions","title":"initialization functions","text":"<ul> <li>keyboardInit</li> <li>keyboardSetLayout</li> <li>keyboardSetBuffer</li> <li>keyboardClearBuffer</li> </ul>"},{"location":"kernel-API/keyboard-input/#promting","title":"promting","text":"<ul> <li>prompt</li> <li>interruptPrompting</li> </ul>"},{"location":"kernel-API/keyboard-input/#key-pressrelease-handlers","title":"key press/release handlers","text":"<ul> <li>keyboardSetKeyPressHandler</li> <li>keyboardSetKeyReleaseHandler</li> <li>keyboardResetKeyPressHandler</li> <li>keyboardResetKeyReleaseHandler</li> </ul>"},{"location":"kernel-API/keyboard-input/#convert-scancode-letter","title":"convert scancode &lt;=&gt; letter","text":"<ul> <li>keyboardGetScancode</li> <li>keyboardGetLetter</li> </ul>"},{"location":"kernel-API/keyboard-input/#shortcuts-handling-functions","title":"shortcuts handling functions","text":"<ul> <li>shortcutsReset</li> <li>setShortcut</li> </ul>"},{"location":"kernel-API/keyboard-input/#type-defs","title":"type defs","text":"<ul> <li>_kbdBuffer</li> <li>onKeyPressHanlder</li> <li>onKeyReleaseHanlder</li> <li>_shortcut</li> <li>onShortcutHandler</li> <li>_kbdLayout</li> </ul>"},{"location":"kernel-API/keyboard-input/#initialization-functions_1","title":"Initialization functions","text":""},{"location":"kernel-API/keyboard-input/#keyboardinit","title":"keyboardInit","text":"<p>&gt;&gt; Syntax: <pre><code>void    keyboardInit(void);\n</code></pre></p> <p>&gt;&gt; Description:</p> <p>initializes the keyboard driver by setting the keyboard buffer the current tty keyboard buffer, and default to the US keyboard layout.</p>"},{"location":"kernel-API/keyboard-input/#keyboardsetlayout","title":"keyboardSetLayout","text":"<p>&gt;&gt; Syntax: <pre><code>void keyboardSetLayout(_kbdLayout layout);\n</code></pre></p> <p>&gt;&gt; Description:</p> <p>Sets the keyboard layout to the provided layout (_kbdLayout).</p>"},{"location":"kernel-API/keyboard-input/#keyboardsetbuffer","title":"keyboardSetBuffer","text":"<p>&gt;&gt; Syntax: <pre><code>void keyboardSetBuffer(_kbdBuffer buffer);\n</code></pre></p> <p>&gt;&gt; Description:</p> <p>Sets the keyboard buffer to the provided buffer (_kbdBuffer).</p>"},{"location":"kernel-API/keyboard-input/#keyboardclearbuffer","title":"keyboardClearBuffer","text":"<p>&gt;&gt; Syntax: <pre><code>void keyboardClearBuffer(void);\n</code></pre></p> <p>&gt;&gt; Description:</p> <p>Clears the keyboard buffer.</p>"},{"location":"kernel-API/keyboard-input/#promting_1","title":"Promting","text":""},{"location":"kernel-API/keyboard-input/#prompt","title":"prompt","text":"<p>&gt;&gt; Syntax: <pre><code>char    *prompt(char *promtMessage, char *buffer);\n</code></pre></p> <p>&gt;&gt; Description:</p> <p>Prompts the user with the provided message and waits for the user to enter a string of characters, which will be stored in the provided buffer.</p> <p>&gt;&gt; Parameters:</p> <ul> <li>promtMessage: The message to be displayed to the user.</li> <li>buffer: The buffer to store the user input.</li> </ul> <p>&gt;&gt; Returns:</p> <p>The buffer containing the user input.</p> <p>&gt;&gt; Note:</p> <ul> <li>can be interrupted with (interruptPrompting).</li> <li>buffer overflow ?!</li> </ul>"},{"location":"kernel-API/keyboard-input/#interruptprompting","title":"interruptPrompting","text":"<p>&gt;&gt; Syntax: <pre><code>void interruptPrompting(void);\n</code></pre></p> <p>&gt;&gt; Description:</p> <p>Interrupts the current prompting operation.</p>"},{"location":"kernel-API/keyboard-input/#key-pressrelease-handlers_1","title":"Key press/release handlers","text":""},{"location":"kernel-API/keyboard-input/#keyboardsetkeypresshandler","title":"keyboardSetKeyPressHandler","text":"<p>&gt;&gt; Syntax: <pre><code>void keyboardSetKeyPressHandler(onKeyPressHanlder handler);\n</code></pre></p> <p>&gt;&gt; Description:</p> <p>Sets the key press handler to the provided handler (onKeyPressHanlder).</p>"},{"location":"kernel-API/keyboard-input/#keyboardsetkeyreleasehandler","title":"keyboardSetKeyReleaseHandler","text":"<p>&gt;&gt; Syntax: <pre><code>void keyboardSetKeyReleaseHandler(onKeyReleaseHanlder handler);\n</code></pre></p> <p>&gt;&gt; Description:</p> <p>Sets the key release handler to the provided handler (onKeyReleaseHanlder).</p>"},{"location":"kernel-API/keyboard-input/#keyboardresetkeypresshandler","title":"keyboardResetKeyPressHandler","text":"<p>&gt;&gt; Syntax: <pre><code>void keyboardResetKeyPressHandler(void);\n</code></pre></p> <p>&gt;&gt; Description:</p> <p>Resets the key press handler to the default handler (tty compatible).</p>"},{"location":"kernel-API/keyboard-input/#keyboardresetkeyreleasehandler","title":"keyboardResetKeyReleaseHandler","text":"<p>&gt;&gt; Syntax: <pre><code>void keyboardResetKeyReleaseHandler(void);\n</code></pre></p> <p>&gt;&gt; Description:</p> <p>Resets the key release handler to the default handler (tty compatible).</p>"},{"location":"kernel-API/keyboard-input/#convert-scancode-letter_1","title":"Convert scancode &lt;=&gt; letter","text":""},{"location":"kernel-API/keyboard-input/#keyboardgetscancode","title":"keyboardGetScancode","text":"<p>&gt;&gt; Syntax: <pre><code>uint8_t keyboardGetScancode(uint8_t letter);\n</code></pre></p> <p>&gt;&gt; Description:</p> <p>Returns the scancode of the provided letter.</p>"},{"location":"kernel-API/keyboard-input/#keyboardgetletter","title":"keyboardGetLetter","text":"<p>&gt;&gt; Syntax: <pre><code>uint8_t keyboardGetLetter(uint8_t scancode);\n</code></pre></p> <p>&gt;&gt; Description:</p> <p>Returns the letter of the provided scancode.</p>"},{"location":"kernel-API/keyboard-input/#shortcuts-handling-functions_1","title":"Shortcuts handling functions","text":""},{"location":"kernel-API/keyboard-input/#shortcutsreset","title":"shortcutsReset","text":"<p>&gt;&gt; Syntax: <pre><code>void shortcutsReset(void);\n</code></pre></p> <p>&gt;&gt; Description:</p> <p>Resets all the shortcuts.</p>"},{"location":"kernel-API/keyboard-input/#setshortcut","title":"setShortcut","text":"<p>&gt;&gt; Syntax: <pre><code>void setShortcut(_shortcut shortcut, onShortcutHandler handler);\n</code></pre></p> <p>&gt;&gt; Description:</p> <p>Sets the provided shortcut (_shortcut) to the provided handler (onShortcutHandler).</p>"},{"location":"kernel-API/keyboard-input/#type-defs_1","title":"type defs","text":""},{"location":"kernel-API/keyboard-input/#_kbdbuffer","title":"_kbdBuffer","text":"<pre><code>typedef struct kbdBuffer {\n    uint8_t     buffer[MAX_KEYBOARD_BUFFER];\n    uint32_t    index;\n    uint32_t    size;\n} _kbdBuffer;\n</code></pre> <p>&gt;&gt; Description:</p> <p>The _kbdBuffer struct represents a keyboard buffer.</p> <p>&gt;&gt; Fields:</p> <ul> <li>uint8_t buffer[MAX_KEYBOARD_BUFFER]: the buffer to store the keyboard input.</li> <li>uint32_t index: the current index in the buffer.</li> <li>uint32_t size: the size of the buffer.</li> </ul>"},{"location":"kernel-API/keyboard-input/#onkeypresshanlder","title":"onKeyPressHanlder","text":"<pre><code>typedef void (*onKeyPressHanlder)(uint8_t);\n</code></pre> <p>&gt;&gt; Description:</p> <p>The onKeyPressHanlder is a function pointer type that represents a key press handler.</p> <p>&gt;&gt; Parameters:</p> <ul> <li>uint8_t: pressed letter. (!= scancode)</li> </ul>"},{"location":"kernel-API/keyboard-input/#onkeyreleasehanlder","title":"onKeyReleaseHanlder","text":"<pre><code>typedef void (*onKeyReleaseHanlder)(uint8_t);\n</code></pre> <p>&gt;&gt; Description:</p> <p>The onKeyReleaseHanlder is a function pointer type that represents a key release handler.</p> <p>&gt;&gt; Parameters:</p> <ul> <li>uint8_t: the scancode of the released key.</li> </ul>"},{"location":"kernel-API/keyboard-input/#_shortcut","title":"_shortcut","text":"<pre><code>typedef struct shortcut {\n    char                key;\n    uint8_t             flagedModifiers;\n    onShortcutHandler   handler;\n} _shortcut;\n</code></pre> <p>&gt;&gt; Description:</p> <p>The _shortcut struct represents a keyboard shortcut.</p> <p>&gt;&gt; Fields:</p> <ul> <li>char key: the key of the shortcut.</li> <li>uint8_t flagedModifiers: the modifiers of the shortcut. (ctrl | alt | shift)</li> <li>onShortcutHandler handler: the handler of the shortcut.</li> </ul>"},{"location":"kernel-API/keyboard-input/#onshortcuthandler","title":"onShortcutHandler","text":"<pre><code>typedef void (*onShortcutHandler)(void);\n</code></pre> <p>&gt;&gt; Description:</p> <p>The onShortcutHandler is a function pointer type that represents a shortcut handler.</p>"},{"location":"kernel-API/keyboard-input/#_kbdlayout","title":"_kbdLayout","text":"<pre><code>typedef union kbdLayout {\n    struct keyboardViews kbdV;\n    uint8_t *views[2];\n} _kbdLayout;\n</code></pre> <p>&gt;&gt; Description:</p> <ul> <li>The _kbdLayout union represents a keyboard layout.</li> <li>the keyboard layout can be accessed as a struct (keyboardViews) or as an array of uint8_t pointers.</li> <li>keyboard layouts are declared in the keyboardDriver.c file.</li> </ul>"},{"location":"kernel-API/ports-io/","title":"Ports IO","text":""},{"location":"kernel-API/ports-io/#functions","title":"Functions:","text":"<ul> <li>portByteIn</li> <li>portByteOut</li> <li>portWordIn</li> <li>portWordOut</li> <li>ioWait</li> </ul>"},{"location":"kernel-API/ports-io/#portbytein","title":"portByteIn","text":"<p>&gt; Syntax: <pre><code>uint8_t portByteIn(uint16_t port);\n</code></pre></p> <p>&gt; Description: Reads a byte from the specified port.</p>"},{"location":"kernel-API/ports-io/#portbyteout","title":"portByteOut","text":"<p>&gt; Syntax: <pre><code>void portByteOut(uint16_t port, uint8_t data);\n</code></pre></p> <p>&gt; Description: Writes a byte to the specified port.</p>"},{"location":"kernel-API/ports-io/#portwordin","title":"portWordIn","text":"<p>&gt; Syntax: <pre><code>uint16_t portWordIn(uint16_t port);\n</code></pre></p> <p>&gt; Description: Reads a word (16 bit) from the specified port.</p>"},{"location":"kernel-API/ports-io/#portwordout","title":"portWordOut","text":"<p>&gt; Syntax: <pre><code>void portWordOut(uint16_t port, uint16_t data);\n</code></pre> &gt; Description: Writes a word (16 bit) to the specified port.</p>"},{"location":"kernel-API/ports-io/#iowait","title":"ioWait","text":"<p>&gt; Syntax: <pre><code>void ioWait(void);\n</code></pre></p> <p>&gt; Description: Wait a very small amount of time (1 to 4 microseconds, generally). Useful for implementing a small delay for PIC remapping on old hardware.</p>"},{"location":"kernel-API/serial-communication/","title":"Serial Communication","text":""},{"location":"kernel-API/serial-communication/#functions","title":"Functions","text":"<ul> <li>initSerial</li> <li>isTransmitEmpty</li> <li>serialPutChar</li> </ul>"},{"location":"kernel-API/serial-communication/#initserial","title":"initSerial","text":"<p>&gt; Syntax: <pre><code>int initSerial(void);\n</code></pre></p> <p>&gt; Description:</p> <p>Initializes the serial communication using the UART protocol.</p> <p>This function configures the COM1 port with the following settings: - Baud rate: 9600 - Data bits: 8 - Stop bits: 1 - Parity: None - Flow control: None (relies on THR status)</p> <p>Returns <code>0</code> on success, <code>1</code> if the serial chip is faulty.  </p>"},{"location":"kernel-API/serial-communication/#istransmitempty","title":"isTransmitEmpty","text":"<p>&gt; Syntax: <pre><code>int isTransmitEmpty(void);\n</code></pre></p> <p>&gt; Description:</p> <p>Checks if the transmit buffer is empty.</p> <p>This function returns <code>1</code> if the transmit buffer is empty, otherwise it returns <code>0</code>.</p>"},{"location":"kernel-API/serial-communication/#serialputchar","title":"serialPutChar","text":"<p>&gt; Syntax: <pre><code>uint8_t serialPutChar(char c);\n</code></pre></p> <p>&gt; Description:</p> <p>Sends a character over the serial port.</p> <p>This function places the character <code>c</code> into the transmit buffer and returns <code>1</code>. If the buffer is full, it waits until the buffer is empty and then places the character in the buffer.</p>"},{"location":"kernel-API/serial-communication/#note","title":"Note","text":"<p>All these functions use the COM1 port for serial communication.</p>"},{"location":"kernel-API/tty/","title":"TTY","text":""},{"location":"kernel-API/tty/#functions","title":"Functions","text":"<ul> <li>putChar</li> </ul>"},{"location":"kernel-API/tty/#putchar","title":"putChar","text":"<p>&gt;&gt; Syntax: <pre><code>uint8_t putChar(char c);\n</code></pre></p> <p>&gt;&gt; Description:</p> <p>Displays the character <code>c</code> on the VGA screen at the current cursor position and adds it to the tty buffer.</p> <p>&gt;&gt;&gt; Functionality:</p> <ul> <li>Displays the character <code>c</code> on the VGA screen at the current cursor position.   </li> <li>Adds the character and its associated color to the tty buffer.  </li> <li>Updates cursor position (X, Y) after printing the character.  </li> <li>Scrolls the screen when the cursor reaches (MAX_COLUMNS, MAX_ROWS).  </li> <li>Handles special characters:</li> </ul> character Represenation Terminal action \\n newline Moves the printing position to the beginning of the next line. \\r carriage return Moves the cursor to the beginning of the current line. \\t tab Advances the cursor by a tab space. \\b backspace Moves the printing position to the previous character position, unless the current position is the start of a line. \\033xx;..;xxm colors Applies text color and formatting, using ansi sequences. <p>&gt;&gt; Return Value:</p> <ul> <li>Returns 1 if the character was successfully printed.  </li> <li>Returns 0 if the character couldn't be printed.</li> </ul>"},{"location":"kernel-API/vga-display/","title":"vga display","text":""},{"location":"kernel-API/vga-display/#functions","title":"Functions","text":"<ul> <li>putCellOnVga</li> <li>setVgaColor</li> </ul>"},{"location":"kernel-API/vga-display/#putcellonvga","title":"putCellOnVga","text":"<p>&gt;&gt; Syntax: <pre><code>void putCellOnVga(_vgaCell cell, uint8_t x, uint8_t y);\n</code></pre></p> <p>&gt;&gt; Description:</p> <p>Takes a _vgaCell, which contains a character and its associated color, and prints it at the specified position (x, y) on the VGA screen. Uses the color information stored in the data struct to display the character with the correct color.</p> <p>&gt;&gt; Parameters:</p> <ul> <li>cell: A _vgaCell to be displayed.</li> <li>x: The X-coordinate on the VGA screen where the cell will be displayed.</li> <li>y: The Y-coordinate on the VGA screen where the cell will be displayed.</li> </ul>"},{"location":"kernel-API/vga-display/#setvgacolor","title":"setVgaColor","text":"<p>&gt;&gt; Syntax: <pre><code>void setVgaColor(uint8_t ansiNbr);\n</code></pre></p> <p>&gt;&gt; Description:</p> <p>Sets the current text or background color based on the provided <code>ansiNbr</code>.  It converts the ANSI color code into a corresponding VGA color and stores it as the current color for subsequent text or background rendering.</p> <p>&gt;&gt; Supported Color Codes:</p> Color Name VGA Text Color Background Color VGA Bright Text Color Bright Background Color Black 0 30 40 8 90 100 Blue 1 34 44 9 94 104 Green 2 32 42 10 92 102 Cyan 3 36 46 11 96 106 Red 4 31 41 12 91 101 Magenta 5 35 45 13 95 105 Yellow 6 33 43 14 93 103 White 7 37 47 15 97 107 Default - 39 49 - - - Reset - 0 0 - - -"}]}